#include "ccp.h"
#include "stdio.h"

u32 now_us; // emulated time in microseconds

struct test_conn {
    u32 curr_cwnd;
    u32 curr_rate;
};

static void test_ccp_set_cwnd(struct ccp_datapath *dp, struct ccp_connection *conn, u32 cwnd) {
    struct test_conn *c = (struct test_conn*) ccp_get_impl(conn);
    c->curr_cwnd = cwnd;
}

static void test_ccp_set_rate(struct ccp_datapath *dp, struct ccp_connection *conn, u32 rate) {
    struct test_conn *c = (struct test_conn*) ccp_get_impl(conn);
    c->curr_rate = rate;
}

static void test_ccp_set_rate_rel(struct ccp_datapath *dp, struct ccp_connection *conn, u32 cwnd) {
    return;
}

static int test_ccp_send_msg(struct ccp_datapath *dp, struct ccp_connection *conn, char *msg, int msg_size) {
    printf("CCP sent message: [");
    for (int i = 0; i < msg_size; i++) {
        printf("%02x, ", msg[i]);
    }
    printf("]\n");
    return 0;
}

static u32 test_ccp_time_now(void) {
    return now_us;
}

static u32 test_ccp_since_usecs(u32 then) {
    return then - now_us;
}

static u32 test_ccp_after_usecs(u32 usecs) {
    return now_us + usecs;
}

int main(int argc, char **argv) {
    int ok = 0;
    now_us = 0;
    struct ccp_datapath dp = {
        .set_cwnd = test_ccp_set_cwnd,
        .set_rate_abs = test_ccp_set_rate,
        .set_rate_rel = test_ccp_set_rate_rel,
        .send_msg = test_ccp_send_msg,
        .now = test_ccp_time_now,
        .since_usecs = test_ccp_since_usecs,
        .after_usecs = test_ccp_after_usecs,
    };

    struct test_conn my_conn = {
        .curr_cwnd = 0,
        .curr_rate = 0,
    };

    printf("starting libccp test...\n");

    ok = ccp_init(&dp);
    if (ok < 0) {
        printf("ccp_init error: %d\n", ok);
        goto ret;
    }

    // a fake flow arrives!
    struct ccp_datapath_info info = {
        .init_cwnd = 100,
        .mss = 10,
        .src_ip = 1,
        .src_port = 2,
        .dst_ip = 3, 
        .dst_port = 4,
        .congAlg = "test",
    };

    struct ccp_connection *conn = ccp_connection_start((void*) &my_conn, &info);

    printf("start ok\n");

    char fold[380] = {
        0x04,                   // INSTALL_FOLD
        0xbe,                   // length = 190 * 2
        0x01, 0x00, 0x00, 0x00, // sock_id = 1
        0x25, 0x00, 0x00, 0x00, // num_instrs = 0x25 = 37
        0x0e, 0xc7, 0x07, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0e, 0xca, 0x0a, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0e, 0xc6, 0x06, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0e, 0xc2, 0x02, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0e, 0xc9, 0x09, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0e, 0xc8, 0x08, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0x3f,
        0x0e, 0xc3, 0x03, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0e, 0xc5, 0x05, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0e, 0xc4, 0x04, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x01, 0xc7, 0x07, 0x00, 0x00, 0xc0, 0x0c, 0x00, 0x00, 0x40,
        0x01, 0xc6, 0x06, 0x00, 0x00, 0xc0, 0x08, 0x00, 0x00, 0x40,
        0x0a, 0x80, 0x08, 0x00, 0x00, 0xc0, 0x08, 0x00, 0x00, 0x40,
        0x01, 0xc8, 0x08, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x02, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x40,
        0x01, 0xc2, 0x02, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x40,
        0x01, 0xc3, 0x03, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80,
        0x01, 0xc4, 0x04, 0x00, 0x00, 0xc0, 0x06, 0x00, 0x00, 0x40,
        0x01, 0xc5, 0x05, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x40,
        0x01, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x40,
        0x05, 0x80, 0x04, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0c, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80,
        0x01, 0xcb, 0x0b, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x0d, 0x80, 0x08, 0x00, 0x00, 0x40, 0x0b, 0x00, 0x00, 0xc0,
        0x02, 0x81, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00,
        0x01, 0xcc, 0x0c, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x80,
        0x03, 0x80, 0x0b, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x06, 0xcc, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
        0x0b, 0x80, 0xb4, 0x05, 0x00, 0x00, 0x08, 0x00, 0x00, 0x40,
        0x02, 0x81, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0xc0,
        0x05, 0x82, 0x01, 0x00, 0x00, 0x80, 0x0c, 0x00, 0x00, 0xc0,
        0x01, 0xcd, 0x0d, 0x00, 0x00, 0xc0, 0x02, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x09, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00,
        0x06, 0xc9, 0x0d, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80,
        0x00, 0x80, 0x0a, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00,
        0x0c, 0xca, 0x0d, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80,
    };

    char pattern[24] = {
        0x03,                               // INSTALL_PATTERN
        0x0c,                               // length = 12 * 2
        0x01, 0x00, 0x00, 0x00,             // sock_id = 1
        0x03, 0x00, 0x00, 0x00,             // num_states = 3
        0x01, 0x06, 0x90, 0x38, 0x00, 0x00, // set cwnd = 14480 bytes
        0x04, 0x06, 0xe8, 0x03, 0x00, 0x00, // waitrel 1000/1000 = 1 RTT
        0x05, 0x02,                         // report
    };

    // fake a fold function and pattern message arriving
    ok = ccp_read_msg(fold, 380);
    if (ok < 0) {
        printf("read fold error: %d\n", ok);
        goto ret;
    }

    printf("fold ok\n");

    ok = ccp_read_msg(pattern, 48);
    if (ok < 0) {
        printf("read pattern error: %d\n", ok);
        goto ret;
    }

    printf("pattern ok\n");

    // advance time
    now_us++;

    conn->prims.rtt_sample_us = 4242; // prevent minrtt = 0
    ok = ccp_invoke(conn);
    if (ok < 0) {
        printf("invoke1 ok\n");
    } else {
        printf("no ccp_invoke error on divide by zero: %d\n", ok);
        goto ret;

    }

    conn->prims.snd_cwnd = my_conn.curr_cwnd * info.mss;
    conn->prims.rtt_sample_us = 4242;
    conn->prims.bytes_acked = 100;
    conn->prims.packets_acked = 10;

    now_us++;

  ret:
    ccp_free();
    return 0;
}
